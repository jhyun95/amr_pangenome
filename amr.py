#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Tue Mar 17 18:43:05 2020

@author: jhyun95

Scripts for managing AMR annotation (not analysis), including 
a wrapper for CARD's RGI tool.
"""

import subprocess as sp
import os
import pandas as pd
import numpy as np
import networkx as nx

from pangenome import generate_annotations, breakdown_feature_name

# Manually selected AROs corresponding to drug classes and superclasses
DRUG_CLASS_AROS = [
    'ARO:3000007', 'ARO:3000008', 'ARO:0000004', # beta-lactam, penam, monobactam 
    'ARO:0000032', 'ARO:0000020', 'ARO:0000016', # cephalosporin, carbapenem, aminoglycoside
    'ARO:0000001', 'ARO:0000017', 'ARO:0000000', # fluoroquinolone, lincosamide, macrolide
    'ARO:3000387', 'ARO:3004116', 'ARO:3000050', # phenicol, nitrofuran, tetracycline
    'ARO:0000042', 'ARO:3000171', 'ARO:3000282', # glycylcycline, diaminopyrimidine, sulfonamide
    'ARO:3000081'                                # glycopeptide
]


def add_probable_hits(df_aro, df_prob, organism, print_additions=False):
    '''
    Combines CARD hits from build_resistome(), with extra
    hits from generate_probable_hits_from_annotations(). 
    df_prob should not be used directly, but should be manually
    curated before combining with actual CARD hits.
    
    Parameters
    ----------
    df_aro : pd.DataFrame
        CARD hits from build_resistome(). Assumes first column
        has AROs and all following columns are drug relevance.
    df_prob : pd.DataFrame
        Probable AMR hits from generate_probable_hits_from_annotations().
        Will be filtered down by organism and drugs in df_aro.
    organism : str
        Organism to filter for. Should match "org" column values in df_prob. 
    print_additions : bool
        If True, prints annotations of added probable hits (default False)
        
    Returns
    -------
    df_aro_ext : pd.DataFrame
        Contains CARD + probable hits, while maintaining the format
        of df_aro. For probable hits matched to CARD hits, ARO column
        has the ARO(s) of the matched hit(s) preceded by an asterisk.
        For probable hits inferred directly from annotation, ARO column
        has "Inferred".
    '''
    drugs_of_interest = df_aro.columns[1:]
    dfp = df_prob[df_prob.org == organism] # filter down to relevant organism
    dfp = dfp[dfp.drug.map(lambda x: x in drugs_of_interest)] # filter down to relevant drugs
    col_order = df_prob.columns.tolist()
    aro_pos = col_order.index('related_aros')
    drug_pos = col_order.index('drug')
    annot_pos = col_order.index('shared_annot')
    
    df_aro_ext = df_aro.copy(deep=True)
    for row in dfp.itertuples(name=None):
        feature = row[1]; drug = row[drug_pos+1]
        related_aros = str(row[aro_pos+1]); annot = row[annot_pos+1] 
        if (';' in related_aros) or (str(related_aros).isnumeric()): # matched multiple or single ARO
            aro_label = '*' + related_aros
        else: # did not match CARD hit, inferred from annotation
            aro_label = 'Inferred'
        if print_additions:
            print(feature, drug, annot) 
        new_features = {feature: {'ARO': aro_label, drug: 1.0}}
        df_new = pd.DataFrame.from_dict(new_features, orient='index')
        df_aro_ext = df_aro_ext.append(df_new.reindex(df_aro.columns, axis=1))
    return df_aro_ext
        

def generate_probable_hits_from_annotations(df_aro, annotations_file,
        exclude=['hypothetical protein'], check_drug_mentions=True, 
        G_aro=None, aro_names={}, manual_annots={}, ignore_case=True):
    '''
    Attempts to identify probable AMR-associated features by identifying
    features with identical generic annotations to features flagged by CARD/RGI, 
    or those containing related drug keywords from the CARD ontology or from 
    manual curation.
    
    Parameters
    ----------
    df_aro : pd.DataFrame
        df_aro as generated by build_resistome()
    annotations_file : str
        Path to gene/allele annotations, see pangenome.generate_annotations()
    exclude : list
        List of annotations to ignore (default ['hypothetical protein'])
    check_drug_mentions : bool
        If True, includes features in which the annotation directly 
        mentions the drug (or its drug class if G_aro is not None), in
        addition to similarity to CARD hit (default True)
    G_aro : nx.DiGraph
        ARO graph from construct_aro_to_drug_network(). If not None and 
        check_drug_mentions is True, will also try to find probable features 
        based on mentions of drug class. Limited to DRUG_CLASS_AROS (default None)
    aro_names : dict
        AROs-annotations map, from construct_aro_to_drug_network(). Used only
        if check_drug_mentions is True and G_aro is provided (default {})
    manual_annots : dict
        Exact phrases in annotations to look for in specific drugs or drug classes, 
        provided as {drug : [iterable of exact phrases}. Default {}.
    ignore_case : bool
        If True, ignores the case when matching annotations (default True)
        
    Returns
    -------
    df_prob : pd.DataFrame
        DataFrame indexed by feature name, with columns for drug,
        related CARD hit features, related AROs, T/F if the probable
        hit shares the same gene cluster, and raw annotation. 
    '''
    
    ''' Extract annotations of CARD hits '''
    df_aro_annot = generate_annotations(
        features=df_aro.index, 
        annotation_files=[annotations_file])
    df_aro_all = df_aro.copy()
    df_aro_all['annot'] = df_aro_annot.values
    
    ''' Map generic annotations of CARD hits to drugs and features '''
    drugs_of_interest = df_aro_all.columns[1:-1]
    annot_to_amr = {} # maps annotations:drug:(feature, ARO pairs)
    for data in df_aro_all.itertuples(name=None):
        card_feature = data[0]; aro = data[1]; annot = data[-1]
        drug_binary = data[2:-1] # 1s or NaNs for drug relevance
        drug_indices = np.argwhere(~np.isnan(drug_binary)).T[0]
        drugs = drugs_of_interest[drug_indices] # +1 skip ARO column
        if len(drugs) > 0:
            if not annot in annot_to_amr:
                annot_to_amr[annot] = {drug:[[],[]] for drug in drugs}
            for drug in drugs: # make an entry for all related drugs
                if not drug in annot_to_amr[annot]:
                    annot_to_amr[annot][drug] = [[],[]]
                annot_to_amr[annot][drug][0].append(card_feature)
                annot_to_amr[annot][drug][1].append(str(aro))
    
    ''' Compress CARD-related annotations '''
    for annot in annot_to_amr:
        for drug in annot_to_amr[annot]:
            alleles = ';'.join(annot_to_amr[annot][drug][0])
            unique_aros = ';'.join(set(annot_to_amr[annot][drug][1]))
            annot_to_amr[annot][drug] = (alleles, unique_aros) # annotation:drug:(card-hit alleles, unique AROs)
    
    ''' Get annotation-matched hits for each drug '''
    term_to_aro = {v:k for k,v in list(aro_names.items())}
    excluded_annots = set(exclude)
    probable_amr = {}
    
    ''' Optionally checking for related terms '''
    search_terms = {}
    if check_drug_mentions: # checking annotation for drug mentions
        for drug in drugs_of_interest: # check annotation against all drugs of interest
            search_terms[drug] = [drug] # check mentions of exact drug name
            if '/' in drug: # combination therapy, check for individual drugs
                search_terms[drug] += drug.split('/')
            if not G_aro is None: # check drug class level terms if possible
                class_terms = []
                for drug_class_aro in DRUG_CLASS_AROS: # check drug against curated drug classes
                    for subdrug in search_terms[drug]: # just [drug] for monotherapies, individual drugs for combination
                        if subdrug in term_to_aro: 
                            drug_aro = term_to_aro[subdrug]
                            if nx.has_path(G_aro, drug_class_aro, drug_aro):
                                drug_class = aro_names[drug_class_aro]
                                drug_class = drug_class.replace('antibiotic','').strip() # reduce to just name
                                class_terms.append(drug_class)
                search_terms[drug] += class_terms
                
    ''' Adding manually curated terms '''
    for drug in [x for x in list(manual_annots.keys()) if x in drugs_of_interest]:
        if not drug in search_terms:
            search_terms[drug] = manual_annots[drug]
        else:
            search_terms[drug] += list(manual_annots[drug]) 
    search_terms = {k:set(v) for k,v in list(search_terms.items())} # remove redundancies
    print(search_terms)
    
    ''' Screen annotations from shared or relevant terms '''
    columns = ('feature', 'drug', 'shared_annot', 'card_hits', 'related_aros')
    selected_features = []
    with open(annotations_file) as f:
        for line in f:
            data = line.strip().split('\t')
            feature = data[0]; annots = data[1:]
            annots = [x for x in annots if not x in excluded_annots]
            for annot in annots:
                annot_lower = annot.lower()
                if annot in annot_to_amr: # checking identical annotations to CARD hits
                    for drug in annot_to_amr[annot]: 
                        card_hits = annot_to_amr[annot][drug][0]
                        related_aros = annot_to_amr[annot][drug][1]
                        selected_features.append( (feature, drug, annot, card_hits, related_aros) )
                for drug in drugs_of_interest: # checking keywords derived from CARD ontology and/or manual curation
                    if drug in search_terms:
                        for search_term in search_terms[drug]:
                            found = (search_term.lower() in annot_lower) if ignore_case else (search_term in annot)
                            if search_term in annot or search_term.lower() in annot_lower: 
                                card_hits = np.nan
                                related_aros = search_term
                                selected_features.append( (feature, drug, annot, card_hits, related_aros) )                                
                                break
    df_prob = pd.DataFrame(columns=columns, data=selected_features)
                        
    ''' Check for shared gene clusters '''
    shared_gene = []
    for row in df_prob.itertuples(name=None):
        probable_feature = row[1]; related_hits = row[4]
        name, ctype, cnum, vtype, vnum = breakdown_feature_name(probable_feature)
        probable_cluster = name + '_' + ctype + str(cnum)
        is_shared = False
        if pd.notnull(related_hits): # hit from similarity to CARD hit
            for hit in related_hits.split(';'):
                name, ctype, cnum, vtype, vnum = breakdown_feature_name(hit)
                related_cluster = name + '_' + ctype + str(cnum)
                if related_cluster == probable_cluster:
                    is_shared = True; break
        shared_gene.append(is_shared)
    df_prob['shared_gene'] = shared_gene
    df_prob.sort_values(by='drug', inplace=True)
    return df_prob


def run_rgi(fasta_in, rgi_out, rgi_args={'-a':'DIAMOND', '-n':1}, clean_headers=True):
    ''' 
    RGI wrapper for FNA (contig) or FAA (protein) files. Optionally cleans
    files up (needed for some PATRIC FAA files where headers contain
    characters incompatible with json importing).
    
    Parameters
    ----------
    fasta_in : str
        Path to FNA or FAA file to be annotated.
    rgi_out : str
        Path to output RGI files. Recommended that this is in its own folder
    rgi_args : dict
        Additional args for rgi main, other than -i, -o and -t.
        (default {'-a':'DIAMOND', '-n':1})
    clean_headers : bool
        If true, creates a copy of the import fasta with shortened headers
        (i.e. header.split()[0] that may resolve some RGI import issues (default True).
    '''
    if clean_headers: # shorten headers in fasta, create *.tmp copy of fasta  
        fasta_tmp = fasta_in + '.tmp'
        with open(fasta_in, 'r') as f_in:
            with open(fasta_tmp, 'w+') as f_out:
                for line in f_in:
                    output = line.split()[0] if line[0] == '>' else line
                    f_out.write(output.strip() + '\n')
        fasta = fasta_tmp
    else: # use original file
        fasta = fasta_in
    
    mode = 'contig' if fasta_in[-4:].upper() == '.FNA' else 'protein'
    args = ['rgi', 'main', '-i', fasta, '-o', rgi_out, '-t', mode]
    for key, value in list(rgi_args.items()):
        args += [key, str(value)]
    print(' '.join(args))
    print(sp.check_output(args))
    
    if clean_headers: # delete temporary fasta
        os.remove(fasta_tmp)

        
def build_resistome(rgi_txt, drugs, G_aro, skip_loose=True):
    '''
    Processes the generated txt file after running RGI on a non-redundant
    CDS pan-genome, as described by df_alleles. Yields a table with all RGI-detected
    alleles as index, a column for their matched ARO, and binary columns based
    on their relevance to drugs of interest.
    
    Parameters
    ----------
    rgi_txt : str
        Path to RGI outputted text file
    drugs : dict
        Dictionary mapping drugs of interest to AROs
    G_aro : nx.DiGraph 
        ARO network for linking AMR genes to drugs, from construct_aro_to_drug_network()
    skip_loose : bool
        If True, skips Loose hits from RGI (default True)
        
    Returns
    -------
    df_rgi : pd.DataFrame
        Dataframe containing raw RGI txt output, optionally with Loose hits removed
    df_aro : pd.DataFrame
        DataFrame indexed by AMR allele, with ARO column + binary column per drug.
        Includes AMR alleles not related to any of the drugs of interest
        (only ARO column will be filled, drug columns would all be np.nan)
    '''
    
    ''' Load RGI hits '''
    df_rgi = pd.read_csv(rgi_txt, sep='\t')
    if skip_loose:
        df_rgi = df_rgi[df_rgi.Cut_Off != 'Loose']
    
    ''' Map RGI alleles to AROs and then to drug '''
    df = df_rgi.loc[:,['ORF_ID', 'ARO']]
    allele_to_drug = {} # maps allele:'ARO':aro or allele:<drug>:1 if ARO is related to that drug
    for row in df.itertuples(name=None):
        ''' Get ARO for RGI allele '''
        i, allele, aro = row
        if allele in allele_to_drug: # allele mapped to multiple AROs
            print('Duplicate hit:', allele)
        allele_to_drug[allele] = {'ARO': aro}
        
        ''' Use ARO to map against drugs '''
        for drug, drug_aro in list(drugs.items()):
            is_related = nx.has_path(G_aro, 'ARO:' + str(aro), drug_aro)
            if is_related: # allele/ARO confers resistance
                allele_to_drug[allele][drug] = 1
    
    ''' Format into DataFrame '''
    aro_alleles = sorted(list(allele_to_drug.keys()))
    column_order = ['ARO'] + sorted(drugs.keys())
    df_aro = pd.DataFrame.from_dict(allele_to_drug, orient='index') #, columns=aro_alleles)
    df_aro = df_aro.reindex(columns=column_order)
    return df_rgi, df_aro
    

def construct_aro_to_drug_network(obo_path):
    '''
    Constructs a DAG from the CARD ARO, such that there exists a path between 
    all AMR genes and their specific impacted drugs. This is acheived by loading 
    all AROs as nodes and adding edges U -> V when:
    1) U "is_a" V (for AMR genes), or reverse V "is_a" U (for drugs)
        - Specific AMR gene inherits resistances of general version of gene
        - Resistance against a drug super class confers resistance to drug members
    2) U has relationship "part_of" or "regulates" V
    3) U has relationship "confers_resistance_to_antibiotic" V
    4) U has relationship "confers_resistance_to_drug_class" V
    5) V has relationship "has_part" U 
        - AMR against a constituent drug contributes to AMR against cotherapy
        
    Parameters
    ----------
    obo_path : str
        Path to CARD ARO network file, usually named aro.obo
    
    Returns
    -------
    G_full : nx.DiGraph
        Networkx DiGraph, such that if an AMR gene contributes to resistance against
        a drug or drug class, there exists a path from the AMR gene ARO to the
        drug/drug class ARO. Nodes are named ARO:#######. Use with G_full.has_path
        to check these relationships, or nx.shortest_path to manually check relationships
    aro_names : dict
        Dictionary mapping ARO:####### to their names
    '''
    
    ''' First identify drug vs gene AROs through connectivity to ARO:1000003 '''
    G_isa = nx.DiGraph(); aro_names = {}
    with open(obo_path, 'r') as f:
        for line in f:
            if line[:8] == 'id: ARO:': # new ARO encountered
                last_aro = line.strip().split()[1]
                G_isa.add_node(last_aro)
            elif line[:5] == 'name:': # name for current ARO encoutnered
                aro_names[last_aro] = line[6:].strip()
            elif line[:5] == 'is_a:': # "is_a" field encountered
                target_aro = line.strip().split()[1]
                G_isa.add_edge(target_aro, last_aro)
            elif line.strip() == '[Typedef]': # end of new ARO terms
                break
    #G_isa.remove_node('ARO:1000001') # root node, links all genes and drugs when present
    drug_aros = nx.descendants(G_isa, 'ARO:1000003') # ARO for “antibiotic molecule”
    drug_aros.add('ARO:1000003')

    ''' Next create the full ontology '''
    G_full = nx.DiGraph()
    valid_relationships = ['part_of', 'regulates', 'confers_resistance_to_antibiotic', 'confers_resistance_to_drug_class']
    with open(obo_path, 'r') as f:
        for line in f:
            if line[:8] == 'id: ARO:': # new ARO encountered
                last_aro = line.strip().split()[1]
                G_full.add_node(last_aro)
            elif line[:5] == 'is_a:': # "is_a" field encountered
                target_aro = line.strip().split()[1]
                if last_aro in drug_aros: # for drugs, build edge drug <- drug superclass
                    G_full.add_edge(target_aro, last_aro)
                else: # for AMR genes, build edge AMR gene -> AMR gene superclass
                    G_full.add_edge(last_aro, target_aro)
            elif line[:13] == 'relationship:': # relationship field encountered
                data = line.split()
                relationship_type = data[1].strip()
                target_aro = data[2]
                if relationship_type in valid_relationships:
                    G_full.add_edge(last_aro, target_aro)
                elif relationship_type == 'has_part':
                    G_full.add_edge(target_aro, last_aro)
            elif line.strip() == '[Typedef]': # end of new ARO terms
                break
    G_full.remove_node('ARO:1000001') # root node, links all genes and drugs when present
    return G_full, aro_names
